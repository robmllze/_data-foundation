//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// GENERATED BY XYZ_GENIE
// See: https://github.com/robmllze/xyz_gen
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

import 'dart:collection';
import 'dart:ui';

import '/_common.dart';

part '_model_job_pub.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

@GenerateModel(
  shouldInherit: true,
  fields: {
    ...PUBLIC_MODEL_FIELDS,
    ('clock_in_regs?', List<ModelRegistration>),
    ('clock_out_regs?', List<ModelRegistration>),
    ('opened_regs?', List<ModelRegistration>),
    ('closed_regs?', List<ModelRegistration>),
    ('todo_book?', Map<DateTime, ModelTodoEntry>),
    ('status?', JobStatusType),
  },
)
abstract class _ModelJobPub extends Model implements PublicModel {}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension ModelJobPubExtension on ModelJobPub {
  //
  //
  //

  bool canClockIn(String? pid) {
    final lastClockIn = this.lastClockInFor(pid);
    final lastClockOut = this.lastClockOutFor(pid);
    if (lastClockIn != null && lastClockOut != null) {
      return lastClockIn.isBefore(lastClockOut);
    }
    if (lastClockIn == null && lastClockOut != null) {
      return true;
    }
    if (lastClockIn == null && lastClockOut == null) {
      return true;
    }
    return false;
  }

  DateTime? lastClockInFor(String? pid) => (this.clockInsFor(pid).toList()..sort()).lastOrNull;

  Iterable<DateTime?> clockInsFor(String? pid) =>
      this.clockInRegs?.where((e) => e.registeredBy == pid).map((e) => e.registeredAt) ?? [];

  bool canClockOut(String? pid) {
    final lastClockIn = this.lastClockInFor(pid);
    final lastClockOut = this.lastClockOutFor(pid);
    if (lastClockIn != null && lastClockOut != null) {
      return lastClockIn.isAfter(lastClockOut);
    }
    if (lastClockIn != null && lastClockOut == null) {
      return true;
    }
    if (lastClockIn == null && lastClockOut == null) {
      return false;
    }
    return false;
  }

  DateTime? lastClockOutFor(String? pid) => (this.clockOutsFor(pid).toList()..sort()).lastOrNull;

  Iterable<DateTime?> clockOutsFor(String? pid) =>
      this.clockOutRegs?.where((e) => e.registeredBy == pid).map((e) => e.registeredAt) ?? [];

  //
  //
  //

  Iterable<({DateTime date, Duration? durationSinceClockIn})> clockedDatesFor(String? pid) {
    final clockInDates = this.clockInsFor(pid).nonNulls;
    final clockOutDates = this.clockOutsFor(pid).nonNulls;

    // Combine and label clock-in and clock-out dates
    final events = <DateTime, bool>{};
    for (var clockIn in clockInDates) {
      events[clockIn] = true; // true for clock-in
    }
    for (var clockOut in clockOutDates) {
      events[clockOut] = false; // false for clock-out
    }

    // Sort the events by date
    final sortedEvents = events.entries.toList()..sort((a, b) => a.key.compareTo(b.key));

    // Prepare to track the last clock-in date
    DateTime? lastClockIn;
    final result = Queue<({DateTime date, Duration? durationSinceClockIn})>();

    // Iterate through sorted events to calculate durations
    for (var event in sortedEvents) {
      final date = event.key.toLocal();
      final clockIn = event.value;
      if (clockIn) {
        lastClockIn = date;
        result.addFirst((date: date, durationSinceClockIn: null)); // No duration for clock-in
      } else {
        if (lastClockIn != null) {
          final durationSinceClockIn = date.difference(lastClockIn);
          result.addFirst((date: date, durationSinceClockIn: durationSinceClockIn));
        } else {
          result.addFirst((date: date, durationSinceClockIn: null));
        }
      }
    }

    return result;
  }
}
